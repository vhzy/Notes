#! https://zhuanlan.zhihu.com/p/555995784
# 26.完整讲解PyTorch多GPU分布式训练代码编写
[官网教程](https://pytorch.org/tutorials/beginner/dist_overview.html)

分布式训练有两种并行方式：
- 数据并行
- 模型并行
![模型并行](https://pic4.zhimg.com/80/v2-08a4d804bae68ac0990fbe543d3f02b2.png)

数据并行用上节文本分类的代码演示，有几个版本
- 单机单卡(最常用)
- 单机多卡(次常用)
- 多机多卡(大数据模型用)

![数据并行](https://pic4.zhimg.com/80/v2-54aba3e1e7ed9b9ea1e4b1482d83b1d4.png)

**单机单卡**，对于几千万参数以内的模型基本够用

常用命令：
1. `torch.cuda.is_available()`
2. 模型拷贝`model.cuda()`,原地操作，调用即可，不用赋值，把模型参数\buffer放到gpu上,时module
里的一个方法
3. 数据拷贝`data = data.cuda`不是原地操作，需要赋值，把训练数据放到gpu上，是tensor的方法
4. 模型保存 `torch.save`
5. 模型加载 `torch.load(file.pt,map_location=torch.device("cuda"/"cuda:0"/"cpu"))`，把模
型加载到哪里，只有cuda表示加到默认的gpu上

![单机单卡](https://pic4.zhimg.com/80/v2-043dd0ee45f1588c6748bc52ca42e861.png)

**单机多卡：**

检测GPU数目常用命令：
1. `torch.cuda.device_count()`
2. 命令行使用`CUDA_VISIVKE_DEVICES="0,1"` 然后再python文件 或者
代码里写 `os.environ["CUDA_VISIBLE_DEVICES"] = "0"` 实现对显卡的约束

`torch.nn.DataParallel` pytorch 1.0版本的,不推荐使用，但是代码改动少
代码：`model = DataParallel(model.cuda(), device_ids = [0, 1, 2, 3])`
注意：模型保存时要加一个module`model.module.state_dict()`

![单机多卡1](https://pic4.zhimg.com/80/v2-c323cd4292025cd2acf034a260c26a45.png)

`torch.nn.parallel.DistributedDataParallel` (DDP, 推荐) 
使用方法：

1. 先初始化一个进程组，gpu之间通信方式nccl",几张gpu卡n_gpus，当前进程在哪个gpu上，
需要在argparse里面接受一个local_rank `rank = args.local_rank`,一个进程跑一张卡
`torch.distributed.init_process_group("nccl",world_size = n_gpus,rank = args.local_rank)`

2. 指定当前进程能使用GPU卡的名称`torch.cuda.set_device(args.local_rank)`

3. 对模型进行包裹 `model = DistributedDataParallel(model.cuda(args.local_rank), device_ids = [args.local_rank])`

4. train_sampler是为了对每张卡的数据分配，即把样本分配到不同的GPU上，这里可以看一下源码
每个训练周期之前，调用`train_sampler.set_epoch(epoch)`充分打乱数据

5. 将上面的sampler传入dataloader，如图前面4~7节所述，dataloader在传入sampler之后
就不用再传入`shuffle`了，相当于数据集已经按照我们想要的方式打乱了

5. 数据也要传入loacl_rank的卡上

6. 需要在命令行执行命令:`python -m torch.distributed.launch --nproc_per_node = n_gpus train.py`
在单节点分布式训练或多节点分布式训练的两种情况下，该工具将为每个节点启动给定数量的进程（--nproc_per_node）。如果用于GPU培训，则此数字需要小于或等于当前系统上的GPU数量（nproc_per_node），并且每个进程将在从GPU 0到GPU（nproc_per_node - 1）的单个GPU上运行。


![单机多卡2.1](https://pic4.zhimg.com/80/v2-dcd27b48ee368c85619ff1170c2ed29f.png)

![单机多卡2.2](https://pic4.zhimg.com/80/v2-d746bd9978df7cecdc9910bbf5ad74e9.png)

**多机多卡：**
`torch.nn.parallel.DistributedDataParallel`

代码编写和单机多卡一样，但是命令行命令需要更多信息
`--nnodes=2`表示有两个节点
`--node_rank=0`当前运行命令在第1个节点上
要在所有节点都执行一次该语句，要修改的就是node_rank参数

![多机多卡](https://pic4.zhimg.com/80/v2-4d086c0d38e18ba095f3cae32eb71ed0.png)



**使用DDL的单机多卡代码如下**
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# File              : gcn_imdb_sentence_classification_multi_gpu_distributed_data_parallel.py
# Author            : admin <admin>
# Date              : 31.12.2021
# Last Modified Date: 06.01.2022
# Last Modified By  : admin <admin>

#  执行命令：python -m torch.distributed.launch --nproc_per_node=2 gcn_imdb_sentence_classification_multi_gpu_distributed_data_parallel.py

import torch
import torch.nn as nn
import torch.nn.functional as F
import torchtext
from torchtext.datasets import IMDB
# pip install torchtext 安装指令
from torchtext.datasets.imdb import NUM_LINES
from torchtext.data import get_tokenizer
from torchtext.vocab import build_vocab_from_iterator
from torchtext.data.functional import to_map_style_dataset
import argparse

import sys
import os
import logging
logging.basicConfig(
    level=logging.WARN,
    stream=sys.stdout,
    format="%(asctime)s (%(module)s:%(lineno)d) %(levelname)s: %(message)s",
)

VOCAB_SIZE = 15000
# 第一期： 编写GCNN模型代码
class GCNN(nn.Module):
    def __init__(self, vocab_size=VOCAB_SIZE, embedding_dim=64, num_class=2):
        super(GCNN, self).__init__()

        self.embedding_table = nn.Embedding(vocab_size, embedding_dim)
        nn.init.xavier_uniform_(self.embedding_table.weight)

        self.conv_A_1 = nn.Conv1d(embedding_dim, 64, 15, stride=7)
        self.conv_B_1 = nn.Conv1d(embedding_dim, 64, 15, stride=7)

        self.conv_A_2 = nn.Conv1d(64, 64, 15, stride=7)
        self.conv_B_2 = nn.Conv1d(64, 64, 15, stride=7)

        self.output_linear1 = nn.Linear(64, 128)
        self.output_linear2 = nn.Linear(128, num_class)

    def forward(self, word_index):
        # 定义GCN网络的算子操作流程，基于句子单词ID输入得到分类logits输出

        # 1. 通过word_index得到word_embedding
        # word_index shape:[bs, max_seq_len]
        word_embedding = self.embedding_table(word_index) #[bs, max_seq_len, embedding_dim]

        # 2. 编写第一层1D门卷积模块
        word_embedding = word_embedding.transpose(1, 2) #[bs, embedding_dim, max_seq_len]
        A = self.conv_A_1(word_embedding)
        B = self.conv_B_1(word_embedding)
        H = A * torch.sigmoid(B) #[bs, 64, max_seq_len]

        A = self.conv_A_2(H)
        B = self.conv_B_2(H)
        H = A * torch.sigmoid(B) #[bs, 64, max_seq_len]

        # 3. 池化并经过全连接层
        pool_output = torch.mean(H, dim=-1) #平均池化，得到[bs, 64]
        linear1_output = self.output_linear1(pool_output)
        logits = self.output_linear2(linear1_output) #[bs, 2]

        return logits


class TextClassificationModel(nn.Module):
    """ 简单版embeddingbag+DNN模型 """

    def __init__(self, vocab_size=VOCAB_SIZE, embed_dim=64, num_class=2):
        super(TextClassificationModel, self).__init__()
        self.embedding = nn.EmbeddingBag(vocab_size, embed_dim, sparse=False)
        self.fc = nn.Linear(embed_dim, num_class)

    def forward(self, token_index):
        embedded = self.embedding(token_index) # shape: [bs, embedding_dim]
        return self.fc(embedded)



# step2 构建IMDB DataLoader

BATCH_SIZE = 64 * 2

def yield_tokens(train_data_iter, tokenizer):
    for i, sample in enumerate(train_data_iter):
        label, comment = sample
        yield tokenizer(comment)

train_data_iter = IMDB(root='.data', split='train') # Dataset类型的对象
tokenizer = get_tokenizer("basic_english")
vocab = build_vocab_from_iterator(yield_tokens(train_data_iter, tokenizer), min_freq=20, specials=["<unk>"])
vocab.set_default_index(0)
print(f"单词表大小: {len(vocab)}")

def collate_fn(batch):
    """ 对DataLoader所生成的mini-batch进行后处理 """
    target = []
    token_index = []
    max_length = 0
    for i, (label, comment) in enumerate(batch):
        tokens = tokenizer(comment)

        token_index.append(vocab(tokens))
        if len(tokens) > max_length:
            max_length = len(tokens)

        if label == "pos":
            target.append(0)
        else:
            target.append(1)

    token_index = [index + [0]*(max_length-len(index)) for index in token_index]
    return (torch.tensor(target).to(torch.int64), torch.tensor(token_index).to(torch.int32))


# step3 编写训练代码
def train(local_rank, train_dataset, eval_dataset, model, optimizer, num_epoch, log_step_interval, save_step_interval, eval_step_interval, save_path, resume=""):
    """ 此处data_loader是map-style dataset """
    start_epoch = 0
    start_step = 0
    if resume != "":
        #  加载之前训过的模型的参数文件
        logging.warning(f"loading from {resume}")
        checkpoint = torch.load(resume, map_location=torch.device("cuda:0")) #可以是cpu,cuda,cuda:index
        model.load_state_dict(checkpoint['model_state_dict'])
        optimizer.load_state_dict(checkpoint['optimizer_state_dict'])
        start_epoch = checkpoint['epoch']
        start_step = checkpoint['step']

    model = nn.parallel.DistributedDataParallel(model.cuda(local_rank), device_ids=[local_rank]) # 模型拷贝，放入DistributedDataParallel


    train_sampler = DistributedSampler(train_dataset)#由于这里要传入dataset，之前在最后传入dataloader要改成dataset
    train_data_loader = torch.utils.data.DataLoader(train_dataset, batch_size=BATCH_SIZE, collate_fn=collate_fn, sampler=train_sampler)
    eval_data_loader = torch.utils.data.DataLoader(eval_dataset, batch_size=8, collate_fn=collate_fn)

    for epoch_index in range(start_epoch, num_epoch):
        ema_loss = 0.
        num_batches = len(train_data_loader)

        train_sampler.set_epoch(epoch_index) # 为了让每张卡在每个周期中得到的数据是随机的

        for batch_index, (target, token_index) in enumerate(train_data_loader):
            optimizer.zero_grad()
            step = num_batches*(epoch_index) + batch_index + 1

            token_index = token_index.cuda(local_rank) # 数据拷贝
            target = target.cuda(local_rank) # 数据拷贝

            logits = model(token_index)
            bce_loss = F.binary_cross_entropy(torch.sigmoid(logits), F.one_hot(target, num_classes=2).to(torch.float32))
            ema_loss = 0.9*ema_loss + 0.1*bce_loss
            bce_loss.backward()
            nn.utils.clip_grad_norm_(model.parameters(), 0.1)
            optimizer.step()

            if step % log_step_interval == 0:
                logging.warning(f"epoch_index: {epoch_index}, batch_index: {batch_index}, ema_loss: {ema_loss.item()}")

            if step % save_step_interval == 0 and local_rank == 0:
                os.makedirs(save_path, exist_ok=True)
                save_file = os.path.join(save_path, f"step_{step}.pt")
                torch.save({
                    'epoch': epoch_index,
                    'step': step,
                    'model_state_dict': model.module.state_dict(),
                    'optimizer_state_dict': optimizer.state_dict(),
                    'loss': bce_loss,
                }, save_file)
                logging.warning(f"checkpoint has been saved in {save_file}")

            if step % eval_step_interval == 0:
                logging.warning("start to do evaluation...")
                model.eval()
                ema_eval_loss = 0
                total_acc_account = 0
                total_account = 0
                for eval_batch_index, (eval_target, eval_token_index) in enumerate(eval_data_loader):
                    total_account += eval_target.shape[0]
                    eval_logits = model(eval_token_index)
                    total_acc_account += (torch.argmax(eval_logits, dim=-1) == eval_target).sum().item()
                    eval_bce_loss = F.binary_cross_entropy(torch.sigmoid(eval_logits), F.one_hot(eval_target, num_classes=2).to(torch.float32))
                    ema_eval_loss = 0.9*ema_eval_loss + 0.1*eval_bce_loss
                acc = total_acc_account/total_account

                logging.warning(f"eval_ema_loss: {ema_eval_loss.item()}, eval_acc: {acc.item()}")
                model.train()

# step4 测试代码
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--local_rank", help="local device id on current node",
                        type=int)
    args = parser.parse_args()

    if torch.cuda.is_available():
        logging.warning("Cuda is available!")
        if torch.cuda.device_count() > 1:
            logging.warning(f"Find {torch.cuda.device_count()} GPUs!")
        else:
            logging.warning("Too few GPU!")
            return
    else:
        logging.warning("Cuda is not available! Exit!")
        return

    n_gpus = 2
    torch.distributed.init_process_group("nccl", world_size=n_gpus, rank=args.local_rank)
    torch.cuda.set_device(args.local_rank)

    model = GCNN()
    #  model = TextClassificationModel()
    print("模型总参数:", sum(p.numel() for p in model.parameters()))
    optimizer = torch.optim.Adam(model.parameters(), lr=0.001)

    train_data_iter = IMDB(root='.data', split='train') # Dataset类型的对象
    train_data_loader = torch.utils.data.DataLoader(to_map_style_dataset(train_data_iter), batch_size=BATCH_SIZE, collate_fn=collate_fn, shuffle=True)

    eval_data_iter = IMDB(root='.data', split='test') # Dataset类型的对象
    eval_data_loader = torch.utils.data.DataLoader(to_map_style_dataset(eval_data_iter), batch_size=8, collate_fn=collate_fn)
    resume = ""

    train(args.local_rank, to_map_style_dataset(train_data_iter), to_map_style_dataset(eval_data_iter), model, optimizer, num_epoch=10, log_step_interval=20, save_step_interval=500, eval_step_interval=300, save_path="./logs_imdb_text_classification", resume=resume)
```