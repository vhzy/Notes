#! https://zhuanlan.zhihu.com/p/542659924
<!-->author: Zhiyuan Han<!-->
<!--> 自动生成目录的方法 ctrL+shift+p打开命令面板 输入Create Table of Contents  <!-->
- [动态规划Part1](#动态规划part1)
- [背包问题](#背包问题)
  - [一. 01背包问题](#一-01背包问题)
    - [问题定义](#问题定义)
    - [逻辑推导](#逻辑推导)
    - [代码实现](#代码实现)
  - [二. 完全背包问题](#二-完全背包问题)
    - [问题定义](#问题定义-1)
    - [逻辑推导](#逻辑推导-1)
    - [代码实现](#代码实现-1)
  - [三. 多重背包问题](#三-多重背包问题)
    - [问题定义](#问题定义-2)
    - [逻辑推导](#逻辑推导-2)
    - [代码实现](#代码实现-2)
  - [四. 分组背包问题](#四-分组背包问题)
    - [问题定义](#问题定义-3)
    - [逻辑推导](#逻辑推导-3)
    - [代码实现](#代码实现-3)
# 动态规划Part1
常用的DP模型
   1. 背包问题
   2. 线性DP
   3. 区间DP
   4. 计数类DP
   5. 数位统计DP
   6. 状态压缩DP
   7. 树形DP
   8. 记忆化搜索——一种DP实现方式

DP的核心在于**状态表示**和**状态转移**


---
# 背包问题
给定一堆物品和一个背包,每个物品有**体积**和**价值**两种属性,在一些限制条件下,将一些物品装入背包,在保证装入物体体积不超过背包体积的情况下,使得总价值最大.根据不同的限制条件,可以分为不同种类的背包问题:
1. 01背包问题:每件物品最多只用一次
2. 完全背包问题:每种物品有无限个
3. 多重背包问题:每种物品的个数有限且不同
4. 分组背包问题:所有物品分为若干组,每组有若干个物品,每组至多选一个物品.

## 一. 01背包问题
### 问题定义
[AcWing 2. 01背包问题](https://www.acwing.com/activity/content/problem/content/997/)

有 N 件物品和一个容量是 V 的背包.每件物品只能使用一次.第 i 件物品的体积是 $v_i$,价值是 $w_i$.求解将哪些物品装入背包,可使这些物品的总体积不超过背包容量,且总价值最大.

### 逻辑推导
动态规划问题主要从两个方面思考:==状态表示==和==状态计算==
除此之外,比较复杂的DP问题还需要考虑**DP优化**,一般来说需要对于问题的**代码**或者说**状态转移方程**做等价变形,可以先把基础形式写出来,在此基础上优化.

**1. 状态表示**

考虑问题需要用几维的状态来表示;对于背包问题可以用两维的状态进行表示$f(i,j)$.
可以从集合的角度考虑状态表示:**集合**和**属性**
1. 集合表示:某一个状态表示的是哪一种集合.
2. 集合属性:状态$f(i,j)$其实是一个数,表示该状态存下来的集合是什么属性（最大值,最小值,元素数量）

对于背包问题,集合表示的所有选法,其条件是:
1. 只从前i个物品中选;
2. 选出来的物品总体积不超过j.
$f(i,j)$:满足上述两个条件的集合里面所有选法的价值的最大值.
把所有答案计算出来后,最终答案即是$f(N,V)$.

**2. 状态计算**

考虑如何把每一个状态算出来,即**集合划分**.
比如对$f(i,j)$ ,考虑如何将其划分成若干个更小的子集合,而这些更小的子集合,又能划分为更更小的子集合.集合的划分有2个原则:
1. 不重:即不重复,某个元素不能既属于子集合A,又属于子集合B;
2. 不漏:即不漏掉任一元素,某个元素不能不属于任何一个子集合.

通常需要满足**不漏**原则,而**不重**不一定需要满足.
下面考虑背包问题中的状态计算,对于第i个物品,$f(i,j)$可以划分成2类:
1. 不包含第i个物品的选法;
2. 包含第i个物品的选法.

![集合划分](https://pic4.zhimg.com/80/v2-43d34d3bbd9fc7358c02c2318fe3f30e.png)
如图所示，左侧选法的最大价值是$f(i-1,j)$，右侧选法的最大价值是$f(i-1,j-v_i)+w_i$。
那么$f(i,j)$最终的取值就是左右两种选法价值最大的一个
**状态转移方程**：
$$
f(i, j)=\max \left\{f(i-1, j), f\left(i-1, j-v_{i}\right)+w_{i}\right\}
$$

![DP分析过程](https://pic4.zhimg.com/80/v2-06c744be1c41be141b8b286c7158ecf3.png)

### 代码实现

**1. 朴素版**

```cpp
#include <iostream>
#include<algorithm>
using namespace std;

const int N = 1010;
int n,m;
int v[N],w[N];
int f[N][N];

int main()
{
   cin>>n>>m;
   for(int i = 1;i<=n;i++) cin >>v[i]>>w[i];
   //考虑最小集合，一件物品都不选f[0][0~m] = 0，全局变量已经自动完成这一步，初始化可以不写
   for(int i =1;i<=n;i++)
   for(int j=1;j<=m;j++)
   {
      f[i][j] = f[i-1][j];
      if(j >= v[i]) f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i]);//右边集合可能为空集
   }
   cout<< f[n][m]<<endl;
   return 0;
}
```

**2. 优化版**

观察状态转移方程，每一个状态f[i]只用到了上一层的状态f[i-1]，同理，j也只用到了小于等于j的状态，也就是说状态的变化是单调的，直观上来看，对应下面的动图，一个状态只用到了它上面一层小于等于当前位置（左边）的状态。所以可以使用**滚动数组**优化。
原先使用二维数组表示的状态现在使用一维滚动数组就可以实现。
对于i-1层来说，只要计算完第i层后，它就没有作用了，因此我们在更新的时候直接在一层上更新即可；
然而如果使用这种原地的更新方式，当我们从小到大遍历j时，新的状态需要用到i-1层左边的状态，但由于进行了原地的更新，左边这些状态是第i层的状态，就不符合状态转移方程了。
于是，对于j来说，我们可以从大往小遍历，这样每次更新用到的左边元素就是i-1层的元素了。
考虑如下案例：
例子如下：假设 N = 4 ，V = 5，对于 i = 0，其 f 全为0。物品的体积和价值分别为：
$$
\begin{cases}
v_1 = 1, v_2 = 2, v_3 = 3, v_4 = 4\\
w_1 = 2, w_2 = 2, w_3 = 4, w_4 = 5
\end{cases}
$$
动态图解：
如果使用动态数组的话，就是使用一行数组，每次从右边往左边填。
![动态规划过程](https://pic4.zhimg.com/80/v2-b573aec8cf8f204988c76003a63e3641.gif)
本案例借鉴自[博客](https://blog.csdn.net/vcj1009784814/article/details/121121462)

在基础版代码上优化时，可以先删除一维数组，然后删除一些等价条件，观察代码的合理性进行修改
```cpp
//01背包滚动数组
#include<iostream>
using namespace std;
const int N=1010;
int n,m;
int v[N],w[N];
int f[N];
int main()
{
	scanf("%d%d",&n,&m);
	for(int i =1;i<=n;i++) scanf("%d%d",&v[i],&w[i]);
	for(int i=1;i<=n;i++){ //注意i要从1开始读，因为状态转移方程里面需要减1
		for(int j=m;j>=v[i];j--)
		{
			f[j] = max(f[j],f[j-v[i]]+w[i]);
		}
	}
	printf("%d",f[m]);
   return 0;
```

## 二. 完全背包问题
### 问题定义
[AcWing 3. 完全背包问题](https://www.acwing.com/activity/content/problem/content/998/)

有 N 件物品和一个容量是 V 的背包.每件物品都有无限件可用.第 i 件物品的体积是 $v_i$,价值是 $w_i$.求解将哪些物品装入背包,可使这些物品的总体积不超过背包容量,且总价值最大.

### 逻辑推导
仿照之前的思考方式，依然从**状态表示**和**状态计算**两方面考虑：

**状态表示**：和01背包问题一样。
1. 集合表示：所有只考虑前i个物品，且总体积不大于j的所有选法;
2. 集合属性：所有选法价值的MAX

**状态计算**：
01背包将集合划分成2类，代表选或不选
完全背包可以按照将第i个物品选几个来将背包划分成若干组

**状态转移方程：**
$$
f(i, j)=\max\left\{f\left(i-1, j-v_{i}*k\right)+w_{i}*k\right\},其中k\varepsilon[0,n]
$$

![完全背包问题分析（y总打码）](https://pic4.zhimg.com/80/v2-61d8741365cb8df41a4c28d83dfde97e.png)

### 代码实现

**1. 朴素版**
```cpp
//现在朴素做法会超时
#include<iostream>
#include<algorithm>
using  namespace std;
const int N = 1010;

int n,m;
int v[N],w[N];
int f[N][N];

int main()
{
   scanf("%d%d",&n,&m);
   for(int i = 1;i <= n; i++) scanf("%d%d",&v[i],&w[i]);
   for(int i = 1;i <= n; i++)//注意i要从1开始读，因为状态转移方程里面需要减1
   for(int j = 0;j <= m;j++)
   for(int k = 0;k *v[i] <= j;k++)
   f[i][j] = max(f[i][j],f[i-1][j-v[i]*k]+k*w[i]);
   printf("%d\n",f[n][m]);
   return 0;
}

```

**2. 优化版**
![完全背包问题优化](https://i.imgur.com/aN51rHQ.png)
经过上图推导，原来的k个状态可以简化为两个状态，$f(i,j)$的推导就和k无关了
**状态转移方程**：
$$
f(i, j)=\left\{f(i-1,j),f\left(i, j-v_{i}\right)+w_{i}\right\},其中k\varepsilon[0,n]
$$

```cpp
#include<iostream>
using namespace std;
const int MAX = 1010;
int n,m;
int v[MAX],w[MAX];
int f[MAX][MAX];
int main()
{
   scanf("%d%d",&n,&m);
   for(int i = 1;i<= n;i++) scanf("%d%d",&v[i],&w[i]);
   for(int i = 1;i<= n;i++)
   for(int j=0;j<=m;j++)
   {
   f[i][j] = f[i-1][j];
   if(v[i]<=j)
   f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i]);
   }
   printf("%d\n",f[n][m]);
   return 0;
}
```
对比01背包的状态转移方程，发现二者其实很像
01背包：`f[i][j] = max(f[i][j],f[i-1][j-v[i]]+w[i])`
完全背包：`f[i][j] = max(f[i][j],f[i][j-v[i]]+w[i])`

写到上面这种程度就已经可以AC了，但实际上我们观察发现，可以和01背包一样使用动态数组优化
注意这里的状态转移方程`f[i][j-v[i]]+w][i]`实际上用的是同一层的f[i]，因此我们就不需要向01背包问题那样使用倒序的方式遍历背包体积了。
```cpp
#include<iostream>
using namespace std;
const int MAX = 1010;
int n,m;
int v[MAX],w[MAX];
int f[MAX];
int main()
{
   scanf("%d%d",&n,&m);
   for(int i = 1;i<= n;i++) scanf("%d%d",&v[i],&w[i]);
   for(int i = 1;i<= n;i++)
   for(int j=v[i];j<=m;j++)
   {
   f[j] = max(f[j],f[j-v[i]]+w[i]);
   }
   printf("%d\n",f[m]);
   return 0;
}
```
这里再和01背包的状态转移方程进行对比：
状态转移方程均为：`f[j] = max(f[j],f[j-v[i]]+w[i])`,区别在于：
01背包从大到小遍历背包体积大小;
完全背包从小到大遍历背包体积大小.

## 三. 多重背包问题
### 问题定义
[AcWing 4. 多重背包问题](https://www.acwing.com/activity/content/problem/content/999/)

有 N 件物品和一个容量是 V 的背包.第i种物品最多有$s_i$件.第 i 件物品的体积是 $v_i$,价值是 $w_i$.求解将哪些物品装入背包,可使这些物品的总体积不超过背包容量,且总价值最大.

### 逻辑推导
仿照之前的思考方式，依然从**状态表示**和**状态计算**两方面考虑：

**状态表示**：和所有背包问题一样。
1. 集合表示：所有只考虑前i个物品，且总体积不大于j的所有选法;
2. 集合属性：所有选法价值的MAX

**状态计算**：
01背包将集合划分成2类，代表选或不选
完全背包可以按照将第i个物品选几个来将背包划分成若干组
多重背包问题除了每种物体个数限制，其余和完全背包一样

**状态转移方程：**
$$
f(i, j)=\max\left\{f\left(i-1, j-v_{i}*k\right)+w_{i}*k\right\},其中k\varepsilon[0,n]
$$


### 代码实现

**1. 朴素版**
先自己尝试写一个朴素版做法，和完全背包的区别在于多重背包需要对物体的个数做一个判断k<=s[i] 
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
int n,m;
const int MAX = 110;
int f[MAX][MAX];
int v[MAX],w[MAX],s[MAX];
int main()
{
   scanf("%d%d",&n,&m);
   for(int i = 1;i<=n;i++) scanf("%d%d%d",&v[i],&w[i],&s[i]);
   for(int i = 1;i<=n;i++)
   for(int j = 0;j<=m;j++)
   for(int k=0;k<=s[i] && k*v[i]<=j;k++)
   f[i][j] = max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k);
   cout<<f[n][m]<<endl;
   return 0;
}
```
我们发现朴素版的做法就可以过了，因为这题数据量较小
然而对于下一题[5. 多重背包问题 II](https://www.acwing.com/problem/content/5/)数据量变大了，朴素做法就行不通了

**2. 优化版**
从状态转移方程入手
$$f[i,j]   = max(f[i-1,j], f[i-1,j-v] + w, f[i-1,j-2v] + 2w ,..., f[i-1,j-sv] + sw)$$


$$f[i,j-v] = max(f[i-1,j-v], f[i-1,j-2v] + w  ,..., f[i-1,j-sv] + (s-1)w + f[i-1,j-(s+1)v] + sw)$$

可以发现下面的式子多出来一项，这是因为：
完全背包没有多出来，因为它的判断条件是背包装不下k*v[i]个物品为止
多重背包问题相当于是再j-v的空间下装入s个物品sv后剩下的体积
由于多出来这一项，多重背包问题就不能和完全背包一样优化了
可以使用**二进制优化**

考虑用一种二进制的方式，比如对于某个 i，其s[i]=1023，则对于该物品，一共需要枚举0,1,2,3,....,1023，共1024种情况。我们可以这样：只保留2的幂的数，然后其他数用2的幂来凑。

如对0到1023，我们只保留1,2,4,8,16,...,512，共10个数字，则0到1023的任意数字，都能由这10个数字组合相加得到。（其实这个思想的本质就是把一个十进制的数，化成二进制表示）。这样以来，我们无需枚举0到1023，只需要枚举1,2,4,8,...,512这10个数即可.

也就是说我们将这些物体打包成10组,每组只能选一次，任意个数的物体都能通过这十组物体凑出来.

上面是恰好s[i]=1023，共枚举$2^{10}$种情况，假设s[i]不是2的幂呢？比如s[i]=200，此时我们需要1,2,4,8,16,32,64，此时不能要128，因为加上128后，能凑出的数的范围就超过200了，而1,2,4,8,16,32,64能凑出的最大的数是127，和200还差73，所以我们补上一个数字73，即我们使用1,2,4,8,16,32,64,73就能凑出0到200内的任意一个数字了。

如何证明使用这几个数就能凑出0到200里的任意一个数字呢？

首先1,2,4,8,16,32,64能够凑出0到127，这是毋庸置疑的。而0到127种的任意一种组合，再额外加一个73，就能凑出73到200，所以上面的8个数就能凑出0到200中的任意一个数。

所以，对于物品i，共有s[i]个，其实我们可以把s[i]个物品，拆分成$log_{s[i]}$个新的物品。然后对这些新的物品，做一次01背包问题即可。

之前的时间复杂度是$O(N*V*S)$，现在的时间复杂度是$O(N*V*logS)$

```cpp
#include <iostream>
using namespace std;
// 因为物品共有N=1000个，而每个物品的s[i]最大到2000，所以每个物品能拆成log(2000)≈11, 实际计算出来是小于11的,
// 所以拆分后的物品总数不超过 1000 * 11 = 11000, 所以我们的N开到11000即可
// 由于数组下标从1开始, 所以我们至少要开到11001
const int N = 11001;

int n, m;

int v[N], w[N], f[N];

int main() {
	scanf("%d%d", &n, &m);
	int cnt = 0;

	for(int i = 1; i <= n; i++) {
        // 处理输入, 将 s[i] 个物品拆分成 log(s[i]) 个
		int a, b, s;
		scanf("%d%d%d", &a, &b, &s);
		int k = 1;
		while(k <= s) {
			cnt++;
			v[cnt] = a * k;
			w[cnt] = b * k;
			s -= k;
			k *= 2;
		}
		if(s > 0) {
			cnt++;
			v[cnt] = a * s;
			w[cnt] = b * s;
		}
	}

	n = cnt; // 总共拆分成了多少个新的物品

    // 对新的物品, 做一次01背包问题, 这里直接写了一维数组优化后的01背包
	for(int i = 1; i <= n; i++) {
		for(int j = m; j >= v[i]; j--) {
			f[j] = max(f[j], f[j - v[i]] + w[i]);
		}
	}

	printf("%d", f[m]);
   return 0;
}

```

## 四. 分组背包问题
### 问题定义
[AcWing 9. 分组背包问题](https://www.acwing.com/problem/content/9/)

有 N 件物品和一个容量是 V 的背包.每组物品有若干个，同一组内的物品最多只能选一个。
每件物品的体积是$v_{ij}$，价值是$w_{ij}$，其中 i 是组号，j 是组内编号。求解将哪些物品装入背包,可使这些物品的总体积不超过背包容量,且总价值最大.

### 逻辑推导
仿照之前的思考方式，依然从**状态表示**和**状态计算**两方面考虑：

**状态表示**：和所有背包问题一样。
1. 集合表示：所有只考虑前i个物品，且总体积不大于j的所有选法;
2. 集合属性：所有选法价值的MAX

**状态计算**：
01背包将集合划分成2类，代表选或不选
完全背包、多重背包可以按照将第i个物品选几个来将背包划分成若干组
分组背包，枚举第i个分组，选哪一个物品或者不选

**状态转移方程：**
$$
f(i, j)=\max\left\{f(i-1,j),f\left(i-1, j-v[i,k]\right)+w[i,k]\right\},其中k\varepsilon[0,n]
$$
![分组背包问题分析](https://pic4.zhimg.com/80/v2-8110c3cb81978939d192e50bcf6f93e2.png)

### 代码实现
```c++
#include <iostream>
using namespace std;
const int N = 110;

int n, m;
int v[N][N], w[N][N], s[N];
int f[N];

int main() {
	scanf("%d%d", &n, &m);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &s[i]);//每组多少个物品
		for(int j = 0; j < s[i]; j++) {
			scanf("%d%d", &v[i][j], &w[i][j]);//每组物品的体积价值
		}
	}

	for(int i = 1; i <= n; i++) {
		for(int j = m; j >= 0; j--) {//从大到小枚举
			for(int k = 0; k < s[i]; k++) {
				if(v[i][k] <= j) {
					f[j] = max(f[j], f[j - v[i][k]] + w[i][k]);
				}
			}
		}
	}
	printf("%d", f[m]);
   return 0;
}

```