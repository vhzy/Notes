- [动态规划Part2](#动态规划part2)
  - [线性DP](#线性dp)
    - [898. 数字三角形](#898-数字三角形)
      - [问题定义](#问题定义)
      - [逻辑推导](#逻辑推导)
      - [代码实现](#代码实现)
    - [895. 最长上升子序列](#895-最长上升子序列)
      - [问题定义](#问题定义-1)
      - [逻辑推导](#逻辑推导-1)
    - [897. 最长公共子序列](#897-最长公共子序列)
      - [问题定义](#问题定义-2)
      - [逻辑推导](#逻辑推导-2)
      - [代码实现:](#代码实现-1)
  - [区间DP](#区间dp)
    - [282. 石子合并](#282-石子合并)
      - [问题定义](#问题定义-3)
      - [逻辑推导](#逻辑推导-3)
      - [代码实现:](#代码实现-2)

# 动态规划Part2

DP问题的时间复杂度怎么算？一般是状态的数量乘以状态转移的计算量
DP问题，是基础算法中比较难的部分，因为它不像其他算法，有个代码模板可以用于记忆。DP问题更偏向于数学问题，它没有一套代码模板，但是有一种思考方式。遇到DP问题，通常我们可以从2个方面进行思考：

**状态表示**
集合表示：考虑是一维还是二维（f[i] 或者 f[i][j]）,考虑这个状态表示的是哪些集合
集合属性：考虑f[i][j]的值，代表的是这个集合的什么属性

**状态计算（状态转移方程）**
DP问题最难的点就在于状态转移（对集合进行划分），即需要自己去想，某个状态，如何从其他的状态转移过来。这个没有固定套路，只能多练，形成经验。DP问题通常都是从实际问题抽象来的，针对某一种DP问题，只要尝试并发现某种状态转移的方式是可行的，是能求出最终解的，那么形成经验后，再遇到该类DP问题，便能更快的解决。

## 线性DP

状态转移方程呈现出一种线性的递推形式的DP,可能是一维线性也可能是二维线性，我们将其统称为==线性DP==。
下面通过具体例题，对线性DP问题的解题过程进行讲解。

### [898. 数字三角形](https://www.acwing.com/problem/content/900/)
#### 问题定义
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大.

#### 逻辑推导
**状态表示**
1. 集合表示：所有从起点，走到(i,j)的路径
2. 集合属性：集合种所有路径上的数字之和的最大值

**状态计算**
集合分为**来自左边**和**来自右边**

**状态转移方程：**
$$
f[i][j]=\max (f[i-1][j-1], f[i-1][j])+a[i][j]
$$

**时间复杂度：** 状态表示$O(N^2)$ * 状态转移$O(1)$ = $O(N^2)$

![数字三角形分析](https://pic4.zhimg.com/80/v2-8f5d761df744bad0987cdc0bc5aaf85f.png)
#### 代码实现 
从上往下求最大值
```cpp
#include<iostream>
using namespace std; 
const int N = 510,INF=1e9;
int n;
int a[N][N];
int f[N][N];
int main()
{
    scanf("%d",&n);
    for(int  i = 1;i <= n;i++)
    for(int j = 1;j <= i;j++)
    scanf("%d",&a[i][j]);

    for(int i = 0;i <= n;i++)//通过设置负无穷，就不用写特判条件了
    for(int j = 0;j<=i+1;j++)//i+1是因为右边元素从右上方来有一条路径
    f[i][j] = -INF;//注意这里设置成正无穷，要从0开始初始化
    f[1][1] = a[1][1];
    for(int i = 2;i <= n;i++)
    for(int j = 1;j <= i;j++)
    f[i][j] = max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);
    int res = -INF;
    for(int i = 1;i <= n;i++) res = max(res,f[n][i]);
    printf("%d\n",res);
    return 0;
}

```
如果不用置`INF`,也可以对每一层的最左边和最右边特判:
```cpp
#include <iostream>
using namespace std;
const int N = 510;

int a[N][N]; // 存储三角形

int f[N][N]; // 存储状态

int n;

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= i; j++) scanf("%d", &a[i][j]);
	}

	f[1][1] = a[1][1];
	for(int i = 2; i <= n; i++) {
		for(int j = 1; j <= i; j++) {
			if(j == 1) f[i][j] = f[i - 1][j] + a[i][j];
			else if(j == i) f[i][j] = f[i - 1][j - 1] + a[i][j];
			else f[i][j] = std::max(f[i - 1][j - 1], f[i - 1][j]) + a[i][j];
		}
	}

    // 最终的答案, 就是最后一层的所有点的 f[i][j] 中的最大值
	int res = f[n][1];
	for(int i = 2; i <= n; i++) {
		res = max(res, f[n][i]);
	}

	printf("%d", res);
}

```
还可以从下往上求最大值，这样最后一行就不用枚举了;而且每个点都由其左下或右下的点转移过来，且每个点一定存在左下的点和右下的点，就无需做特判了:
```cpp
#include <iostream>

const int N = 510;

int a[N][N]; // 存储三角形

int f[N][N];

int n;

int main() {
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		for(int j = 1; j <= i; j++) scanf("%d", &a[i][j]);
	}

    // 初始化底层的 f[i][j]
	for(int i = 1; i <= n; i++) f[n][i] = a[n][i];

    // 从下往上走
	for(int i = n - 1; i >= 1 i--) {
		for(int j = 1; j <= i; j++) {
			f[i][j] = std::max(f[i + 1][j], f[i + 1][j + 1]) + a[i][j];
		}
	}

	printf("%d", f[1][1]);
    return 0;
}
```
### [895. 最长上升子序列](https://www.acwing.com/problem/content/897/)
#### 问题定义
给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少.
#### 逻辑推导
**状态表示**
1. 集合表示：f[i]表示所有以第i个数结尾的上升子序列. 
2. 集合属性：集合里面每一个上升子序列的长度的最大值.

**状态计算**
我们可以考虑子序列的倒数第二个数，我们根据这些子序列中，倒数第二个数是a[i - 1]，a[i - 2]，a[i - 3]，…，a[0]，来进行划分。一共划分为i个子集合。
当然，由于子序列需要是严格单调递增，所以并不是[0,i - 1]中的所有位置都可以作为倒数第二个位置。必须满足a[j] < a[i]，才行。

**状态转移方程：**
$$
f[i]=\max (f[j]+1),其中j \varepsilon[0,i - 1]
$$

**时间复杂度：** 状态表示$O(N)$ * 状态转移$O(N)$ = $O(N^2)$

```c++
#include<iostream>
using namespace std;
const int N = 1010;
int n;
int a[N],f[N];
int main()
{
    scanf("%d",&n);
    for(int i = 1;i<=n;i++) scanf("%d",&a[i]);
    for(int i =1;i<=n;i++)
    {
        f[i] = 1;//只有a[i]一个数
        for(int j = 1;j<i;j++)
        if(a[i] > a[j])
        f[i] = max(f[i],f[j] + 1);
    }
    int res = 0; 
    for(int i = 1;i<=n;i++) res = max(res,f[i]);
    printf("%d\n",res);
    return 0;
}
```
可以记录转移过程，dp问题有一部分需要求方案，其实就是需要记录一下dp转移的过程,这里展示一下转移的逆序输出:
```c++
#include<iostream>
using namespace std;
const int N = 1010;
int n;
int a[N],f[N],g[N];
int main()
{
    scanf("%d",&n);
    for(int i = 1;i<=n;i++) scanf("%d",&a[i]);
    for(int i =1;i<=n;i++)
    {
        f[i] = 1;//只有a[i]一个数
        g[i] = 0;
        for(int j = 1;j<i;j++)
        if(a[i] > a[j])
        if(f[i]<f[j]+1)
        {
            f[i] = f[j] + 1;
            g[i] = j;
        }
    }
    int k = 1;
    for(int i = 1; i <= n; i++)
    if(f[k] < f[i])
    k = i;
    printf("%d\n",f[k]);
    for(int i = 0,len = f[k]; i < len; i++)//把转移过程逆序输出
    {
        printf("%d ",a[k] );
        k = g[k];
    }
    return 0;
}
```

### [897. 最长公共子序列](https://www.acwing.com/problem/content/899/)
#### 问题定义
给定两个长度分别为 N 和 M 的字符串 A 和 B，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少.
#### 逻辑推导
**状态表示**
1. 集合表示：f[i][j]表示，在第一个序列的前i个字母中出现，且在第二个序列的前j个字母中出现的全部子序列（已经是公共子序列了）
2. 集合属性：f[i][j]的值，是这些子序列中，最长的子序列的长度

**状态计算**
下面我们考虑如何对f[i][j]表示的集合进行划分。我们用a来表示第一个字符串，b来表示第二个字符串。我们根据这些子序列是否包含a[i]，是否包含b[j]，来进行集合的划分。则可以分为4种子集合

- 不包含a[i]，不包含b[j]（用二进制位来表示是否包含，则是00）
- 包含a[i]，不包含b[j]（10）
- 不包含a[i]，包含b[j]（01）
- 包含a[i]，包含b[j]（11）
f[i, j]则是这4个中的最大者。

![最长公共子序列](https://pic4.zhimg.com/80/v2-d38e86421a9a0dfa1b5e6331718f239c.png)

其中00，可以直接用f[i - 1, j - 1] 表示，11可以直接用f[i - 1, j - 1] + 1来表示，但注意11需要满足a[i] = b[j]才行。

比较难的地方在于01和10，01表示，这些子序列中包含b[j]，但是不包含a[i]，注意是包含b[j]，即这些子序列的最后一位是b[j]，为了方便叙述，我们将01这个子集合表示为A，而f[i - 1, j]表示的集合（暂且称为A’），是所有在字符串a的前i - 1个字母中出现，且在字符串b的前j个字母中出现的子序列（b[j]不一定是子序列的最后一位）。

需要特别注意，A’并不等于A，A’和A是包含关系，A是A’的子集。即f[i - 1, j]表示的集合，实际是要大于01这个集合的。

但是我们可以用f[i - 1, j]来代替 01这个集合,因为f[i-1,j]被包含于f[i,j],也就是说使用f[i-1,j]的最大值并不一定等于01集合的最大值，但是这个值一定在f[i,j]的范围内，即重复的集合运算并不会影响最终的最大值结果。举例如下：

对于集合1 2 3 4 5，我们要求这个集合的最大值，我们先对集合进行划分，先求子集1 2 3 的最大值，为3，再求子集 3 4 5的最大值，为5，再求这两个子集的最大者，为5，则整个集合的最大值为5。

注意到，2个子集是有重合部分的（重合了3这个数），但是并不影响求解整个集合的最大值。

即，只要全部子集加起来，能够涵盖掉整个集合（即使子集之间有重合），那么对求整个集合的最大值，是没有影响的。

对于10这个子集，同理，可以用f[i, j - 1]来代替它。而观察到，f[i - 1, j]和 f[i, j - 1]，实际是包含了00这个子集的，所以编写代码时，可以省略00这个子集。

**状态转移方程：**
$$
f[i][j]=\max (f[i-1][j],f[i][j-1],f[i-1][j-1]+1)
$$

**时间复杂度：** 状态表示$O(N^2)$ * 状态转移$O(1)$ = $O(N^2)$

#### 代码实现:
```cpp
#include<iostream>
using namespace std;
const int N = 1010;
int n,m;
char a[N],b[N];
int f[N][N];

int main()
{
    scanf("%d%d",&n,&m);
    scanf("%s%s",a+1,b+1);//注意一下这里的读入，由于需要用到上一个状态，ab要从1开始读
    for(int i = 1; i <= n; i++)
    for(int j = 1;j <= m;j++)
    {
        f[i][j] = max(f[i-1][j],f[i][j-1]);
        if(a[i] == b[j]) f[i][j] = max(f[i][j],f[i-1][j -1]+1);
    }
    printf("%d\n",f[n][m]);
    return 0;
}
```

我们不妨使用**滚动数组**优化一下
观察上述的状态转移方程可以发现，状态f[i][j]只和f[i-1][j]，f[i][j - 1]，f[i - 1][j - 1] 这三个状态有关。即f[i][j]只和上一行当前列，当前行左侧一列，以及上一行左侧一列，这三个状态有关。故我们可以考虑用滚动数组的思想来优化空间。由于需要依赖当前行左侧的状态，则我们需要从左往右更新状态，而依赖上一行当前列，则我们从上往下更新状态，对于左上角的状态，我们用一个临时变量进行存储即可。
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 1010;
int f[N];

int main() {
    int n, m;
    string a, b;
    cin >> n >> m;
    cin >> a >> b;

    for (int i = 1; i <= n; i++) {
        int old = 0, temp = 0; // 存储左上角的状态, 注意要定义在这里, 注意每一轮更新时, 需要重置为0
        for (int j = 1; j <= m; j++) {
            temp = f[j];// 暂存当前这一列, 作为左上角
            f[j] = max(f[j - 1], f[j]); // 左侧, 上侧
            if (a[i - 1] == b[j - 1]) f[j] = max(f[j], old + 1); // 左上角
            // 将当前列作为下一次迭代的左上角
            old = temp;
        }
    }

    printf("%d\n", f[m]);
    return 0;
}

```

---

## 区间DP

状态表示是某一个区间，比如f[i, j]表示的是[i ,j] 这个区间

### [282. 石子合并](https://www.acwing.com/problem/content/284/)
#### 问题定义
见链接.
#### 逻辑推导
**状态表示**
1. 集合表示：f[i, j]表示的集合是：将第i堆石子，到第j堆石子，合并成一堆石子的所有合并方式.
2. 集合属性：f[i, j]的值是，所有合并方式中，代价最小的合并方式的代价。则最终的答案就是f[1, n]

**状态计算**
由于将第i堆石子，到第j堆石子，合并成一堆，最后一次操作，一定是将相邻的2堆石子合并。则我们以最后一次合并时，的分界线，来进行集合的分类。

则可以分成（假设[i,j]区间内共有k堆石子，k=j-i+1）：

左边1堆石子，右边k-1堆
左边2堆，右边k-2堆
左边3，右边k-3
左边4，右边k-4
…
左边k-1，右边1
一共k-1个子集，只需要求其中的最小值即可，
最后一步的合并代价始终是sum[i,j]，这个可以用第一章的前缀和来处理。
**状态转移方程：**
$$
f(i,j)=\min (f(i,k)+f(k+1,j)+s[j]-s[i-1]),其中k \varepsilon[i,j - 1]
$$

**时间复杂度：** 状态表示$O(N^2)$ * 状态转移$O(N)$ = $O(N^3)$

区间DP，需要注意循环时的顺序，我们需要保证在计算f[i,j]时，需要的其他全部的f的值，都已经被算好了。所以这里我们按区间长度从小到大来枚举，先枚举区间长度为1，所有的f[i,j]，再枚举区间长度为2，…

所有区间DP类的问题，都可以用这种模式来做，先从小到大循环区间的长度（区间长度1，2，3，…），然后内层循环就循环区间的起点

#### 代码实现:
```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int N = 310, INF = 0x3f3f3f3f;

int n, s[N], f[N][N];


int main() {
	memset(f, 0x3f, sizeof f);
	scanf("%d", &n);
	for(int i = 1; i <= n; i++) {
		scanf("%d", &s[i]);
		s[i] += s[i - 1]; // 直接计算前缀和
	}
	
	for(int i = 1; i <= n; i++) f[i][i] = 0;

	for(int len = 2; len <= n; len++) {
		for(int i = 1; i + len - 1 <= n; i++) {
			int j = i + len - 1;
			for(int k = i; k <= j - 1; k++) {
				f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
			}
		}
	}

	printf("%d", f[1][n]);

	return 0;
}

```

小结：

对于状态转移的思考，是对状态表示的集合进行划分，根据前面的几道例题，可以得知，我们划分集合时，通常都是根据最后一步的操作，来进行划分的，只要能够划分成功，就能得出状态转移方程。

动态规划为什么快？是因为我们用一个状态来表示了一堆方案的一种属性，即用一个数表示了一堆东西。相比而言，暴力（DFS）会遍历每一种方案，所以它慢。

---

