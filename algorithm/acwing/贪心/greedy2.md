- [贪心Part2](#贪心part2)
  - [排序不等式](#排序不等式)
    - [AcWing 913. 排队打水](#acwing-913-排队打水)
      - [问题定义](#问题定义)
      - [逻辑推导](#逻辑推导)
      - [代码实现](#代码实现)
  - [绝对值不等式](#绝对值不等式)
    - [AcWing 104. 货仓选址](#acwing-104-货仓选址)
      - [问题定义](#问题定义-1)
      - [逻辑推导](#逻辑推导-1)
      - [代码实现](#代码实现-1)
  - [推公式](#推公式)
    - [AcWing 125. 耍杂技的牛](#acwing-125-耍杂技的牛)
      - [逻辑推导](#逻辑推导-2)
      - [代码实现](#代码实现-2)

# 贪心Part2
这节主要围绕不等式和推公式讲贪心例题

## 排序不等式

### [AcWing 913. 排队打水](https://www.acwing.com/problem/content/description/915/)

#### 问题定义
有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？

#### 逻辑推导
假设各个同学的打水时间为：`3 6 1 4 2 5 7`

并且就按照这个顺序来打水。

当第一个同学打的时候，后面所有同学都要等他，所以等待的总时长要加上一个`3 * 6`，第二个同学打的时候，后面所有同学也都要等他，所以要加上个`6 * 5`，以此类推，所有同学等待的总时长为

`3 * 6 + 6 * 5 + 1 * 4 + 4 * 3 + 2 * 2 + 5 * 1`

假设各个同学打水花费的时长为 `t1，t2，t3，…，tn`

则按照次序打水，总的等待时长为：

`t1 * (n-1) + t2 * (n-2) + ... + tn * 1`

直观的感受告诉我们，将打水时长更长的同学，放在队列的末尾，能够使得整体的等待时长更短。那么我们的贪心策略就是，按照打水时长从小到大排序，并依次打水，能使整体的等待时长最短。这跟哈夫曼编码的原理也很类似。

正确性证明：

采用反证法（调整法），假设最优解不是按照从小到大的顺序，则必然存在2个相邻的人，前一个人打水时长比后一个大，即必然存在一个位置i，满足$t_i > t_{i+1}$，那我们尝试把这两个同学的位置交换，看看对总的等待时长有什么影响，这两个同学的交换，只会影响他们两的等待时长，不会影响其他同学的等待时长。

交换前，这部分等待时长为$t_i * (n-i) + t_{i+1} * (n-i-1)$，交换后，这部分等待时长为$t_i+1 * (n-i) + t_i * (n-i-1)$，容易算得，交换后的等待时长变小了，则该方案不是最优解，矛盾了。则最优解就是按照从小到大的顺序依次打水。

#### 代码实现

```cpp
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1e5 + 10;

int n, t[N];

int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) scanf("%d", &t[i]);
	sort(t, t + n);
	long long res = 0;
	for(int i = 0; i < n; i++) {
		res += (n - i - 1) * t[i];
	}
	printf("%lld\n", res);
	return 0;
}

```

## 绝对值不等式

### [AcWing 104. 货仓选址](https://www.acwing.com/activity/content/problem/content/1214/)

#### 问题定义
在一条数轴上有 N 家商店，它们的坐标分别为 $A_1∼A_N$。

现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。

为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。

#### 逻辑推导

假设n个商店在数轴上的坐标依次为：$x1，x2，x3，…，xn$

设仓库的位置为x，则总的距离为

$f(x) = |x1 - x| + |x2 - x| + ... + |xn - x|$

我们要求解的就是$f(x)$的最小值。

我们可以先进行一下分组，1和n为一组，2和n-1为一组…

$f(x) = (|x1 - x| + |xn - x|) + (|x2 - x| + |x_n-1 - x|) + ....$

然后我们单独看一组，任意一组都可以写成形如$|a - x| + |b - x|$的形式，a和b是已知的常数，x是未知数。假设a < b，则容易知道，当x取值在[a,b]这个区间内时，上面的表达式取得最小值b - a，而x取值只要落在[a,b]区间外，则上面的表达式的值一定是大于b - a的。

由此可知，对于分组1和n，只要x取值在[x1,xn]这个区间内，就能使$|x1 - x| + |xn - x|$取得最小值$xn - x1$。同理，对于$|x2 - x| + |x_n-1 - x|$，只要x取值在[x2,x_n-1]区间内，就能使这个部分取得最小值$x_{n-1} - x2…$容易得出，只要取所有分组的区间的交集，即能使总的f(x)最小。即，当n为偶数时，x只要落在最中间2个点之间即可；当n为奇数时，x只需要落在最中间的那个点上即可。

![绝对值不等式](https://pic4.zhimg.com/80/v2-97f8f0eaa30ade3fe006390f61972dd2.png)

#### 代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10;

int n, a[N];

int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) scanf("%d", &a[i]);
	sort(a, a + n);
	int res = 0;
	// n / 2 就是仓库的选址
	for(int i = 0; i < n; i++) res += abs(a[i] - a[n / 2]);
	printf("%d\n", res);
	return 0;
}
```

## 推公式

### [AcWing 125. 耍杂技的牛](https://www.acwing.com/problem/content/127/)

#### 逻辑推导
**结论：** 按照w + s从小到大的顺序，从上往下排，最大的危险系数一定是最小的。

**简单理解：** 把重量轻的牛放下面是很亏的，同样把不强壮的牛放下面也是亏的，所以就尽可能把又重又强壮的牛放下面。

**正确性证明：**
  
按照上面策略得到的答案 >= 最优解
按照上面策略得到的答案 <= 最优解
首先，按照上面的策略得到的是一种方案，而最优解是所有方案中的最小值，所以 按照上面策略得到的答案 >= 最优解。

第二点，用反证法。假设最优解不是按照w + s从小到大排列。则一定存在一个位置i，使得wi + si > w(i+1) + s(i+1)，然后看一下把这两头牛交换，会发生什么变化。同样的，这两头牛的交换，不会影响除这两头牛以外，其他牛的危险系数，所以只看这两头牛的危险系数的变化即可。交换前和交换后，第i和第i+1头牛的危险系数如下
	
|        |         第i个位置上的牛         |          第i+1个位置上的牛           |
| :----: | :-----------------------------: | :----------------------------------: |
| 交换前 |   $w1 + w2 + … + w(i-1) - si$   |     $w1 + w2 + … + wi - s(i+1)$      |
| 交换后 | $w1 + w2 + … + w(i-1) - s(i+1)$ | $w1 + w2 + … + w(i-1) + w(i+1) - si$ |

这几项有公共的部分w1 + w2 + … + w(i-1)，则把这个公共部分减掉，不影响结果

|        | 第i个位置上的牛 | 第i+1个位置上的牛 |
| :----: | :-------------: | :---------------: |
| 交换前 |     $- si$      |   $wi - s(i+1)$   |
| 交换后 |   $- s(i+1)$    |   $w(i+1) - si$   |

随后，对所有项加上一个 si + s(i+1)，转化为正数，方便我们比较

|        | 第i个位置上的牛 | 第i+1个位置上的牛 |
| :----: | :-------------: | :---------------: |
| 交换前 |    $s(i+1)$     |     $wi + si$     |
| 交换后 |      $si$       | $w(i+1) + s(i+1)$ |

由于`wi + si > si`，且根据先前的假设，有`wi + si > w(i+1) + s(i+1)`

所以`wi + si` 大于 `max(si, w(i+1) + s(i+1) )`，进而有 `max( s(i+1), wi + si) > max(si, w(i+1) + s(i+1) )`。即，交换后，第i个和第i+1个位置上的牛中的最大危险系数变小了。

所以，只要存在一个位置i，使得`wi + si > w(i+1) + s(i+1)`，则一定能交换第i和第i+1的位置，使得总体的最大的危险系数不变或者变小。假设最优解不是按照w + s从小到大的顺序排列，则我们通过贪心策略，总是能够交换2个逆序的位置，使得到的结果，不变或者变得更小。因此，贪心得到的答案一定是 <= 最优解的。

正确性得证。

#### 代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 5e4 + 10;

int n;

struct Cow
{
	int w, s;

	bool operator < (const Cow &c) {
		return (w + s) < (c.w + c.s);
	}
} cow[N];

int main() {
	scanf("%d", &n);
	for(int i = 0; i < n; i++) {
		int w, s;
		scanf("%d%d", &w, &s);
		cow[i] = {w, s};
	}

	sort(cow, cow + n);

	int wsum = 0, res = -1e9;
	for(int i = 0; i < n; i++) {
		res = max(res, wsum - cow[i].s);
		wsum += cow[i].w;
	}
	printf("%d\n", res);
	return 0;
}

```
练习一下pair的实现，注意如果对pair排序，默认按照Pair的第一个元素排序
```cpp
#include<iostream>
#include<algorithm>
using namespace std;
typedef pair<int, int> PII;
const int N = 50010;
int n;
PII cow[N];

int main()
{
    scanf("%d", &n);
    for(int i = 0; i < n; i++)
    {
        int w, s;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w};
    }
    sort(cow, cow + n);

    int res = -2e9, sum = 0;
    for(int i = 0; i < n; i++)
    {
        int w = cow[i].second, s = cow[i].first - w;
        res = max(res, sum - s);
        sum += w;
    }
    cout<<res<<endl;
    return 0;
}

```