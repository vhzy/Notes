<div id="article_content" class="article_content clearfix">
    <link rel="stylesheet" href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/ck_htmledit_views-b3c43d3711.css">
            <div id="content_views" class="markdown_views prism-atom-one-dark">
                <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                    <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                </svg>
                <h2><a name="t0"></a><a id="KMP_0"></a>一文看懂<a href="https://so.csdn.net/so/search?q=KMP&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=KMP&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;KMP\&quot;}&quot;}" data-tit="KMP" data-pretit="kmp">KMP</a>算法</h2> 
<p>KMP是一种模式匹配算法。常用于在一个较长的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020" target="_blank" class="hl hl-1" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;字符串\&quot;}&quot;}" data-tit="字符串" data-pretit="字符串">字符串</a>中查找一个较短的字符串。通常称较长的字符串为<strong>主串</strong>，较短的待匹配的字符串为<strong>模式串</strong>。</p> 
<p>比如给定一个主串S = <code>ababacd</code>，一个模式串P = <code>abac</code>，那么最终能够在主串中成功匹配到模式串</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511104058777.png" alt="image-20210511104025001"></p> 
<p>通常，针对某一些算法问题，我们可以首先考虑一个暴力的解法，随后通过寻找规律，来省略掉一些无效的步骤，从而完成优化。</p> 
<p>对于字符串匹配，很容易想到的暴力解法就是使用双指针。</p> 
<p>如主串<code>S</code>的长度为<code>n</code>，模式串<code>P</code>的长度为<code>m</code>（<code>n &gt; m</code>）。定义指针<code>i</code>和<code>j</code>，<code>i</code>初始指向主串的第一个位置，<code>j</code>初始指向模式串的第一个位置。</p> 
<p>我们先假设<code>S</code>中包含了<code>P</code>，则在<code>[1, n]</code>区间内（下标从1开始），一定存在一个位置<code>i</code>，是<code>S</code>匹配<code>P</code>的起始位置。</p> 
<p>如<code>S = ababcd</code>，<code>P = abac</code>，根据上图，我们一眼就能看出，<code>S</code>中包含了<code>P</code>，且起始位置是3。</p> 
<p>所以，我们只需要在<code>[1, n]</code>区间内枚举<code>i</code>，并与<code>P</code>比较，若以某一个<code>i</code>为起点，能够完整匹配<code>P</code>，则找到答案。</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511104806826.png" alt=""></p> 
<p>我们比较主串的<code>S[i]</code>和模式串的<code>P[j]</code></p> 
<ul><li> <p>若二者相等，则<code>i</code>和<code>j</code>都往后移动一位，继续比较<code>S[i]</code>和<code>P[j]</code></p> <p><img src="https://img-blog.csdnimg.cn/20210511105210746.png" alt=""></p> </li><li> <p>若二者不等，则主串中当前位置为起点无法匹配</p> <p><img src="https://img-blog.csdnimg.cn/20210511110115663.png" alt=""></p> <p>将起点往后移一位（<code>i</code>从2开始），继续比较</p> <p><img src="https://img-blog.csdnimg.cn/20210511111508644.png" alt=""></p> </li></ul> 
<p>最终在<code>i = 3</code>为起点时，成功匹配</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511104058777.png" alt=""></p> 
<p>暴力解法写成代码如下</p> 
<pre data-index="0" class="set-code-hide prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> s<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span> <span class="token comment">// 主串S和模式串P的长度</span>
cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> m<span class="token punctuation">;</span>
<span class="token comment">// 读入主串S和模式串P, 下标都从1开始</span>
cin <span class="token operator">&gt;&gt;</span> s <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// 枚举 i = [1, n], 尝试匹配</span>
<span class="token keyword">int</span> i<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i <span class="token operator">+</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 匹配成功, 打印起始坐标</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li></ul></pre> 
<p>暴力解法<code>i</code>最多从1移动到n，每次尝试匹配时，<code>j</code>最多会移动<code>m - 1</code>次，所以暴力解法的时间复杂度为O(n×m)</p> 
<p>那么KMP算法是怎么优化的呢？KMP采用了一种很巧妙的方法，比如上面的<code>S = ababacd</code>，<code>P = abac</code>，当我们进行到这一步时</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511110115663.png" alt=""></p> 
<p>发现<code>S[i] = b</code>与<code>P[j] = c</code>不匹配，但我们能不能利用一下前面已经匹配了的<code>aba</code>呢？答案是可以的，我们观察可以发现，已经匹配的<code>aba</code>，其前缀<code>a</code>和后缀<code>a</code>是相同的，我们可以不用回退指针<code>i</code>，而是移动指针<code>j</code>，即把下面的模式串<code>P</code>往右挪，进行对齐，随后继续比较<code>i</code>和<code>j</code>即可。</p> 
<p><img src="https://img-blog.csdnimg.cn/2021051111383584.png" alt=""></p> 
<p>上面的操作，取决于已匹配的字符串中，<strong>前缀和后缀相等的最大长度</strong>。</p> 
<p>比如对于字符串<code>aba</code>，其所有可能的前缀为<code>{a，ab}</code>（不包含其本身），而其所有可能的后缀为<code>{a，ba}</code></p> 
<p>取<strong>前缀集合</strong>与<strong>后缀集合</strong>的交集，结果为<code>{a}</code>，则对于<code>aba</code>，前缀和后缀相等的最大长度就是1。</p> 
<p>再比如，对于字符串<code>ababa</code>，其所有可能的前缀为<code>{a, ab, aba, abab}</code>，其所有可能的后缀为<code>{a, ba, aba, baba}</code></p> 
<p><strong>前缀集合</strong>与<strong>后缀集合</strong>的交集为<code>{a, aba}</code>，其中长度最大的是<code>aba</code>，所以对于<code>ababa</code>，前缀和后缀相等的最大长度就是3。</p> 
<p>对于一个长度为n的字符串，存在一个最大的k（k &lt; n），使得该字符串的前缀<code>[1,k]</code>和后缀<code>[n-k+1, n]</code>相等。当然，当不存在相等的前缀和后缀时，k为0。</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511142130279.png" alt=""></p> 
<p>这个相等的前缀与后缀有什么作用呢？</p> 
<p>考虑如下情况，当我们匹配了一定的长度时，然后发现<code>S[i]</code>和<code>P[j]</code>不相等，此时我们可以利用前面已经匹配的部分，将模式串<code>P</code>一次性往右移动多个位置，而不移动指针<code>i</code>，那么<code>P</code>需要一次性移动多少呢？这就需要用到上面提到的<strong>前缀后缀相等的最大长度</strong>这个概念了</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511143336778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZjajEwMDk3ODQ4MTQ=,size_16,color_FFFFFF,t_70" alt=""></p> 
<p>假设上图中已经匹配的绿色的部分，其<strong>前缀后缀相等的最大长度</strong>为k，如下图标为粉色的部分</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511144130513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZjajEwMDk3ODQ4MTQ=,size_16,color_FFFFFF,t_70" alt=""></p> 
<p>很明显，我们可以将<code>P</code>串直接往右挪动（实际是回溯指针<code>j</code>，将<code>j</code>往左移动，移动到<code>P</code>串中粉色部分的最右端），使得上下的粉色部分进行对齐，然后接着继续比较<code>S[i]</code>和<code>P[j]</code>即可</p> 
<p><img src="https://img-blog.csdnimg.cn/20210511144905913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZjajEwMDk3ODQ4MTQ=,size_16,color_FFFFFF,t_70" alt=""></p> 
<p>由于，<code>S</code>和<code>P</code>可能在任何一个位置出现不匹配，那么我们对<code>P</code>的每个位置，都需要求解以该位置为终点的<strong>前缀后缀相等的最大长度</strong>，这也是求解KMP算法中最核心的<code>next</code>数组。</p> 
<p>比如对于<code>P = ababac</code>，其<code>next</code>数组求解出来结果如下</p><div class="articleConDownSource" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.8634&quot;}"><a target="_blank" href="https://download.csdn.net/download/newnewman80/3141865" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.1&quot;,&quot;mod&quot;:&quot;&quot;,&quot;extra&quot;:&quot;{\&quot;utm_medium\&quot;:\&quot;distribute.pc_blog_inner_ad.none-task-download-2~default~SEARCH_TARGETING~default-1-3141865-blog-116662859.blog_insert_ad_searchtargetingv1\&quot;,\&quot;dist_request_id\&quot;:\&quot;1660038522855_73874\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1660038522855_73874&quot;,&quot;ab_strategy&quot;:&quot;default&quot;,&quot;index&quot;:&quot;1&quot;,&quot;strategy&quot;:&quot;2~default~SEARCH_TARGETING~default&quot;,&quot;dest&quot;:&quot;https://download.csdn.net/download/newnewman80/3141865&quot;}" data-report-query="spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-1-3141865-blog-116662859.blog_insert_ad_searchtargetingv1&amp;depth_1-utm_source=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-1-3141865-blog-116662859.blog_insert_ad_searchtargetingv1">            <div class="card-left">                <div class="card-left-t">思华科技（上海）有限公司 面试题目</div>                <div class="card-left-b">                    <span class="classfiy">application/msword</span>                    <img class="star contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/components/img/star.png" alt="">                    <span class="text">4星</span>                    <span class="circle"></span>                    <span class="text">超过75%的资源</span>                    <span class="circle"></span>                    <span class="text">25KB</span>                </div>            </div>            <div class="card-right">                <div class="card-right-t"><img class="contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/components/img/arrowDownWhite.png" alt=""></div>                <div class="card-right-b">下载</div>            </div>        </a></div> 
<div class="table-box"><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td><strong>值</strong></td><td>0</td><td>0</td><td>1</td><td>2</td><td>3</td><td>0</td></tr></tbody></table></div>
<p>解释：</p> 
<ul><li><code>next[1] = 0</code>，因为<strong>前缀后缀的长度必须要小于字符串本身</strong>，所以<code>next[i]</code>一定是小于<code>i</code>的，而<code>next[1] = 0</code>也就表示了：<code>a</code>这个字符串，由于不存在前缀与后缀，其前缀与后缀相等的最大长度为0</li><li><code>next[2] = 0</code>，观察<code>ab</code>这个字符串，其可能的前缀只有一个<code>a</code>，可能的后缀也只有一个<code>b</code>，前缀集合与后缀集合的交集为空集。即，不存在相等的前缀和后缀，所以<code>next[2]</code>也为0</li><li><code>next[3] = 1</code>，观察<code>aba</code>这个字符串，其前缀集合为<code>{a, ab}</code>，后缀集合为<code>{a, ba}</code>，二者的交集为<code>{a}</code>，所以相等的前缀后缀的长度就是1</li><li><code>next[4] = 2</code>，观察<code>abab</code>，前缀集合为<code>{a, ab, aba}</code>，后缀集合为<code>{b, ab, bab}</code>，二者的交集为<code>{ab}</code>，这个相等的前缀和后缀的长度就是2</li><li><code>next[5] = 3</code>，观察<code>ababa</code>，前缀集合为<code>{a, ab, aba, abab}</code>，后缀集合为<code>{a, ba, aba, baba}</code>，二者的交集为<code>{a, aba}</code>，其中最大的长度就是3</li><li><code>next[6] = 0</code>，观察<code>ababac</code>，前缀集合为<code>{a, ab, aba, abab, ababa}</code>，后缀集合为<code>{c, ac, bac, abac, babac}</code>，二者的交集为空集，不存在相等的前缀和后缀，所以<code>next[6]</code>为0</li></ul> 
<p>为什么我们的数组下标从1开始，这是为了更方便地处理边界问题，稍后展示代码时就能明白了。</p> 
<p>接下来，有了<code>next</code>数组，KMP算法就变得非常简单了，下面进行代码展示，以<code>s</code>表示主串，<code>p</code>表示模式串，<code>s</code>的长度为<code>n</code>，<code>p</code>的长度为<code>m</code>，且<code>n &gt; m</code></p> 
<pre data-index="1" class="prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token comment">/*1*/</span>	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">/*2*/</span>		<span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">/*3*/</span>		<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token comment">/*4*/</span>		<span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> m<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">/*5*/</span> 	    	<span class="token comment">// 匹配成功, 返回主串的起始坐标i, 下标从1开始</span>
<span class="token comment">/*6*/</span>   		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i <span class="token operator">-</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">/*7*/</span>   		j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 继续后续可能的匹配</span>
<span class="token comment">/*8*/</span>		<span class="token punctuation">}</span>
<span class="token comment">/*9*/</span>	<span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre> 
<p>我们的下标<code>i</code>从1开始，<code>j</code>从<code>0</code>开始，每次比较<code>s[i]</code>和<code>p[j + 1]</code></p> 
<p>第2行的含义是，当<code>j &gt; 0</code>，即先前已经有部分字符串匹配上，且这次没有匹配上时，回溯<code>j</code>，将<code>j</code>置为<code>next[j]</code>。由于此时<code>j</code>指向的是<code>p</code>串中已匹配部分的最后一个位置，<code>next[j]</code>则表示以当前<code>j</code>为终点的字符串，其相等的前缀和后缀的最大长度，这恰好能和上面我们讲解的<code>next</code>数组的定义对上。然后将<code>j</code>置为<code>next[j]</code>，结合上面的图来看，就是将<code>j</code>放到了<code>p</code>串中<strong>粉色部分</strong>的最后一个位置，则下次比较时，应当比较<code>s[i]</code>和<code>p[j + 1]</code>。</p> 
<p>这就是我们代码为什么要将<code>j</code>从0开始枚举，而<code>i</code>从1开始，保持<code>i</code>和<code>j</code>错开一位，而每次比较<code>s[i]</code>和<code>p[j + 1]</code>。</p> 
<p>当第2行的while循环结束时，</p> 
<ul><li>要么是<code>j</code>被置为0了：这种情况就是<code>p</code>串需要从第一位和<code>s</code>串进行比较（从头开始）</li><li>要么是<code>s[i] == p[j + 1]</code>：这种情况就是当前位置匹配上了</li></ul> 
<p>第3行，若当前位置能够匹配上，则将<code>j</code>后移一位</p> 
<p>第4行，若<code>j == m</code>，则说明<code>p</code>串已经匹配到最后一位了（如果当前成功匹配了<code>s[i]</code>和<code>p[m]</code>，则完成匹配，此时<code>j + 1 = m</code>,<code>j = m - 1</code>，由于进入了第3行的<code>if</code>块，进行了<code>j++</code>，所以最后<code>j</code>变为了<code>m</code>），匹配完成，打印出此时<code>s</code>串中匹配的起点，表示找到了一个符合条件的匹配。并将<code>j</code>置为<code>next[j]</code>（往右挪动<code>p</code>串），继续进行后续可能的匹配。</p> 
<p>—2022/06/10更新</p> 
<p>上面的流程， 关键在于理解<code>i</code>和<code>j</code>的含义，可以这样理解，<code>i</code>就是主串<code>S</code>中当前待匹配的位置，而<code>j</code>是模式串中已匹配部分的最后一个位置，所以我们每次需要比较<code>s[i]</code>和<code>p[j + 1]</code>，由于上面我们字符串下标都是从<code>1</code>开始，所以<code>j</code>也可以理解为模式串中前后缀相等的最大<strong>长度</strong>。</p> 
<p>每次匹配时，我们先看一下当前位是否能匹配上，即比较<code>s[i]</code>和<code>p[j + 1]</code>，如果当前位置匹配不上，但先前存在了已匹配的部分，则回溯<code>j</code>，即<code>j = next[j]</code>。一直执行这个判断，直到，当不存在已匹配部分（<code>j = 0</code>）或当前位置能匹配上，则退出<code>while</code>循环，然后根据当前位置是否匹配上，来决定是否对<code>j</code>进行加1操作。</p> 
<p>当然，其实字符串数组下标从正常的0开始，也是可以的。这样<code>j</code>的含义就仅仅是已匹配部分的<strong>最后一个位置</strong>，而不能表示前后缀相等的最大<strong>长度</strong>。如果下标从0开始，则循环中，<code>j</code>的初始值要置为<code>-1</code>，而<code>j &gt;= 0</code>则表示了先前已经匹配了一部分。</p> 
<p><strong>思路总结</strong>：为了更好的理解kmp的代码实际执行流程（更好的记忆算法板子），可以按照这样的思路来进行理解和记忆：</p> 
<p>因为我们不需要回退指针<code>i</code>，所以外层的大循环直接迭代<code>i</code>，在外层循环内，每次先用一个while循环，看一下当前位置是否需要回退指针<code>j</code>，如果不需要回退（已匹配上），或已经退无可退（模式串要从头开始匹配），则退出while循环，然后指针<code>j</code>可能加1也可能不动，随后再判断下已匹配的部分是否达到模式串的末尾。</p><div class="articleConDownSource" data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.8636&quot;}"><a target="_blank" href="https://download.csdn.net/download/qq_38993096/12234691?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-2-12234691-blog-116662859.blog_insert_ad_searchtargetingv1&amp;depth_1-utm_source=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-2-12234691-blog-116662859.blog_insert_ad_searchtargetingv1" data-report-click="{&quot;ab&quot;:&quot;new&quot;,&quot;spm&quot;:&quot;1001.2101.3001.6650.2&quot;,&quot;mod&quot;:&quot;&quot;,&quot;extra&quot;:&quot;{\&quot;utm_medium\&quot;:\&quot;distribute.pc_blog_inner_ad.none-task-download-2~default~SEARCH_TARGETING~default-2-12234691-blog-116662859.blog_insert_ad_searchtargetingv1\&quot;,\&quot;dist_request_id\&quot;:\&quot;1660038522855_73874\&quot;}&quot;,&quot;dist_request_id&quot;:&quot;1660038522855_73874&quot;,&quot;ab_strategy&quot;:&quot;default&quot;,&quot;index&quot;:&quot;2&quot;,&quot;strategy&quot;:&quot;2~default~SEARCH_TARGETING~default&quot;,&quot;dest&quot;:&quot;https://download.csdn.net/download/qq_38993096/12234691&quot;}" data-report-query="spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-2-12234691-blog-116662859.blog_insert_ad_searchtargetingv1&amp;depth_1-utm_source=distribute.pc_blog_inner_ad.none-task-download-2%7Edefault%7ESEARCH_TARGETING%7Edefault-2-12234691-blog-116662859.blog_insert_ad_searchtargetingv1">            <div class="card-left">                <div class="card-left-t">上交 上海交通大学计算机软件复试面试常问问题.rar</div>                <div class="card-left-b">                    <span class="classfiy">rar</span>                    <img class="star contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/components/img/star.png" alt="">                    <span class="text">1星</span>                    <span class="circle"></span>                    <span class="text">超过10%的资源</span>                    <span class="circle"></span>                    <span class="text">164KB</span>                </div>            </div>            <div class="card-right">                <div class="card-right-t"><img class="contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/components/img/arrowDownWhite.png" alt=""></div>                <div class="card-right-b">下载</div>            </div>        </a></div> 
<p>—2022/06/10更新–end</p> 
<p>对于KMP的核心流程，上面的解释已经十分清楚了，然而上面的求解过程需要基于<code>next</code>数组，所以我们仍然需要对<code>p</code>串进行预处理，求出其<code>next</code>数组。好消息是，求解<code>p</code>串的<code>next</code>数组的过程，和上面的算法流程十分相近！</p> 
<p>我们可以对<code>p</code>串自身进行上面的匹配过程！</p> 
<p>由于<code>next[1] = 0</code>，所以我们从第二位开始对<code>p</code>串进行匹配，代码如下</p> 
<pre data-index="2" class="prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 错开一位进行匹配, 每次匹配 i 和 j + 1 位, 第一次则匹配 2 和 1</span>
    <span class="token comment">// 当前面有匹配上的部分时, 看看当前位是否匹配, 若不匹配, 则回溯 j </span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> next<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// 该位匹配上了, 则 j 往后移动一位</span>
    next<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 当前位置的 next[i] = j</span>
<span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre> 
<p><img src="https://img-blog.csdnimg.cn/20210511160741306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ZjajEwMDk3ODQ4MTQ=,size_16,color_FFFFFF,t_70" alt=""></p> 
<p>开始时，<code>i = 2, j = 0</code>，我们仍然比较<code>p[i]</code>和<code>p[j + 1]</code>，此时若<code>p[2] = p[1]</code>，则<code>j++</code>，随后<code>next[i] = j</code>，</p> 
<p>则此时<code>next[2] = 1</code></p> 
<p>更通常的，对于<code>next[i]</code>，如果在当前位置能够匹配上，即<code>p[i] = p[j + 1]</code>，则<code>next[i] = next[i - 1] + 1</code></p> 
<p>如果当前位置无法匹配上，即<code>p[i] != p[j + 1]</code>，则需要将<code>j</code>置为<code>next[j]</code>（由于<code>i</code>总是大于<code>j</code>的，而每次得到<code>next</code>数组的值时，都是通过对<code>next[i]</code>进行赋值完成的。所以此时<code>next[j]</code>一定在先前就被求解出来了），即回溯<code>j</code>，即右移下面的<code>p</code>串，随后继续比较<code>p[i]</code>和<code>p[j + 1]</code>，直到</p> 
<ul><li> <p>满足<code>p[i] = p[j + 1]</code>，则当前<code>next[i] = j + 1</code></p> </li><li> <p>或<code>j</code>回溯为0，仍然<code>p[i] != p[j + 1]</code>，即<code>p[i] != p[1]</code>，则<code>next[i] = 0</code></p> </li></ul> 
<p>由上面的分析可见，求解<code>next</code>数组，与KMP的核心算法流程是一致的。我们通过让模式串<code>p</code>和它自身做模式匹配，求解出其<code>next</code>数组，随后使用<code>p</code>的<code>next</code>数组，完成主串<code>s</code>和模式串<code>p</code>的匹配。</p> 
<p>至此，相信你已经领略到KMP算法的设计之精巧了。下面就尝试一道算法题来结束KMP的学习吧！</p> 
<p><a href="https://www.acwing.com/problem/content/description/833/">Acwing - 831: KMP字符串</a></p> 
<p>或者</p> 
<p><a href="https://leetcode-cn.com/problems/implement-strstr/">Leetcode - 28: 实现strStr()</a></p> 
<p>其中<code>Acwing - 831</code>这道题目的题解如下</p> 
<pre data-index="3" class="set-code-hide prettyprint"><code class="prism language-c has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">,</span> M <span class="token operator">=</span> <span class="token number">1e6</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">char</span> p<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">[</span>M<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">,</span> m<span class="token punctuation">;</span>

<span class="token keyword">int</span> ne<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 由于 C++ 中 next 变量已经在其他的头文件定义了, 所以这里将 next 数组命名为 ne</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> p <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> m <span class="token operator">&gt;&gt;</span> s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 读入p和s时, 从下标为1的位置开始读入    </span>
<span class="token comment">// 先求解p串的next数组</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 回溯j</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>
    ne<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 进行s串和p串的匹配</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>j <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 回溯j</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> j<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>j <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 匹配完成</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> i <span class="token operator">-</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
        j <span class="token operator">=</span> ne<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<div class="hljs-button {2}" data-title="复制"></div></code><div class="hide-preCode-box"><span class="hide-preCode-bt"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li></ul></pre> 
<p>参考链接：<a href="https://www.zhihu.com/question/21923021">https://www.zhihu.com/question/21923021</a></p>
            </div><div><div></div></div>
            <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/editerView/markdown_views-22a2fefd3b.css" rel="stylesheet">
            <link href="https://csdnimg.cn/release/blogv2/dist/mdeditor/css/style-4f8fbf9108.css" rel="stylesheet">
    </div>