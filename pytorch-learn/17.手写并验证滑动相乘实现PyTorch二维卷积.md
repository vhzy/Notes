#! https://zhuanlan.zhihu.com/p/555150121
# 17.手写并验证滑动相乘实现PyTorch二维卷积
 
如果输入输出通道不为1，再加两层循环即可
最外层是输出通道数，第二层是输入通道数
 ```python
 # 17手写滑动相乘
import math
input = torch.randn(5, 5)
kernel = torch.randn(3, 3)
bias = torch.randn(1) #偏置，默认通道为1

#step1 用原始的矩阵运算实现二维卷积,先不考虑batch_size和channel
def matrix_multiplication_for_conv2d(input, kernel,bias = 0,  stride = 1, padding = 0):

    if padding > 0:
        input = F.pad(input, (padding, padding, padding, padding))

    input_h, input_w = input.shape
    kernel_h, kernel_w = kernel.shape


    output_h = (math.floor((input_h - kernel_h ) /stride ) + 1)
    output_w = (math.floor((input_w - kernel_w ) /stride ) + 1)
    output = torch.zeros(output_h, output_w) #初始化输出矩阵
    for i in range(0, input_h - kernel_h + 1, stride):  #对高度维进行遍历
        for j in range(0, input_w - kernel_w + 1, stride): #对宽度维进行遍历
            region  = input[i : i + kernel_h , j : j + kernel_w]
            output[int(i / stride), int(j/stride)] = torch.sum(region * kernel) + bias#逐元素相乘
    return output
#矩阵运算实现卷积结果
mat_mul_conv_output = matrix_multiplication_for_conv2d(input, kernel, padding = 1,bias = bias)
print(mat_mul_conv_output)

#调用API结果
pytorcg_api_conv_output = F.conv2d(input.reshape(1,1, input.shape[0], input.shape[1]),\
    kernel.reshape(1,1,kernel.shape[0],kernel.shape[1]),\
        padding=1,bias = bias)
print(pytorcg_api_conv_output.squeeze(0).squeeze(0))
 ```
