#! https://zhuanlan.zhihu.com/p/542793773

<!-->author: Zhiyuan Han<!-->
<!--> 自动生成目录的方法 ctrL+shift+p打开命令面板 输入Create Table of Contents  <!-->
# PyTorch介绍与张量的创建
之前一直没有时间好好总结pytorch的用法，这里利用假期时间总结一下，形成系统化记忆。

## 张量Tensors
Tensors和NumPy的多维数组ndarrays很像，它们可以共享内存，张量还支持在GPU上运行，并可以自动微分，首先引入torch：
```python
import torch
import numpy as np
```

### 创建张量
1. 从列表中创建张量：
```python
data = [[1.,2],[3,4]]
x_data = torch.tensor(data)
x_data.dtype
```
`out:torch.float32`

**知识点:**
- type()
  - 返回数据结构类型（list、dict、numpy.ndarray 等）.
- dtype()
  - 返回数据元素的数据类型（int、float等）.
  - 备注：
    1. 由于 list、dict 等可以包含不同的数据类型，因此不可调用dtype()函数.
    2. np.array、torch.tensor中要求所有元素属于同一数据类型，因此可调用dtype()函数.
- astype()
  - 改变np.array中所有数据元素的数据类型.
  - 备注：能用dtype() 才能用 astype().

2. 从NumPy array中创建张量：
```python
np_array= np.random.normal((2,3))
x_np = torch.from_numpy(np_array)
x_np
```
`out:torch.float64`

```python
'''
这里补充一下np.random.normal正态分布的使用方法：
np.random.normal(loc,scale,size)
loc:float 均值 默认0
scale:float 方差 默认1.0
size:生成数的个数 
实际上loc和scale都可以list或者tuple的形式传入，如果传入list有两个数，在不指定生成个数的情况下，默认生成两个数，代表在不同均值的高斯分布下生成的情况
这里每行表示在均值2.0，方差3.0和均值3.0方差3.0的情况下各自生成的两个随机数；
注意size列向量个数必须等于传入的list的数的个数。
'''

np_random = np.random.normal((2.0,3.0),(3.0,3.0),(4,2))
np_random
```

```python
c=torch.ones_like(x_np)
```
3. 其他方式创建张量：
- `torch.ones_like(x_np)`
- `torch.zeros_like(x_np)`
- `torch.rand_like(x_np)`

可以直接通过形状创建tensor
```python
shape = (2,3,)#这里list和tuple都可以，最后一个逗号可有可无
rand_tensor = torch.rand(shape)
ones_tensor = torch.ones(shape)
zeros_tensor = torch.zeros(shape)

print(f"Random Tensor: \n {rand_tensor} \n")
print(f"Ones Tensor: \n {ones_tensor} \n")
print(f"Zeros Tensor: \n {zeros_tensor}\n")
```

### 张量操作

张量基本属性
```python
a = torch.rand([2,2,])
a.dtype
a.shape
a.device
```

张量有[100多种操作](https://pytorch.org/docs/stable/torch.html)，tensor默认在cpu上创建，可以通过`to`操作移动到gpu上,然而对于一个大张量来说，将其从cpu上复制到gpu上很耗时间和内存。
```python
if torch.cuda.is_available():
    tensor = tensor.to('cuda')
```
1. **判断张量类型**和**生成张量**常用操作：
```python
'''
判断是否是一个张量,内部操作即isinstance(obj,Tensor)
'''
torch.is_tensor(a) 

'''
判断是否是一个复数类型,在torch中支持torch.complex64和torch.complex128
'''
torch.is_complex(a)

'''
判断是否是浮点型
'''
torch.is_floating_point(a)

'''
判断输入是否是单一的张量且不等于0
'''
torch.is_nonzero(a)

'''
返回输入张量中所有元素的数目
'''
torch.numel(a)

'''
这里以生成全0张量说明传入参数
torch.zeros(*size, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
这里dtype等默认为None时,是通过torch.set_default_tensor_type进行全局定义从而初始化的
'''
torch.zeros([5,5,],dtype = int32)

'''
训练时对于一个epoch进行遍历，用range、arange来生成一组连续的索引
torch.arange(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
从形参可以看出，如果只传入一个参数，那么代表的是end的值
返回一个一维张量，(end-start)\step
'''
torch.arange(0,5,2) #output:[0,2,4]

for i in torch.arange(10):
    print("epoch:",i)

'''
torch.range(start=0, end, step=1, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
返回一个一维张量，维度(end-start)\step +1，将end作为闭区间考虑
这个函数由于和Python本身的range冲突，将被移除，一般来说使用arange即可
'''
torch.range(0,5,1) #output:[0,1,2,3,4,5]

'''
产生一个对角线为1其余元素全0的矩阵
torch.eye(n, m=None, *, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor
'''
torch.eye(5,4)

'''
empty作用就是初始化一块内存放着，里面数据不重要，根本不会用
'''
torch.empty((2,3), dtype=torch.int64)

'''
full作用就是创建全为某个数的矩阵
'''
torch.full((2,2),5, )

```

2. **切片、索引、聚合、旋转**常用操作：
```python
'''
cat作用就是连接多个张量，除了被连接的维度以外其他维度形状必须一样
'''
a = torch.rand([2,2,])
b = torch.rand([2,3,])
torch.cat([a,b],dim = 1) #dim [2,5]
```